<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Pipelining">
    

    <!--Author-->
    
        <meta name="author" content="Yilong Wang">
    

    <!-- Title -->
    
    <title>Rorg_11 | 25HUASHENG</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.jsdelivr.net/npm/bootstrap@3.3.6/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.jsdelivr.net/npm/font-awesome@4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.jsdelivr.net/npm/bootstrap@3.3.6/dist/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                Rorg_11
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <p>Pipelining<br><span id="more"></span></p>
<h1 id="Rechnerorganisasion-TUT-11"><a href="#Rechnerorganisasion-TUT-11" class="headerlink" title="Rechnerorganisasion TUT 11"></a>Rechnerorganisasion TUT 11</h1><h2 id="Pipelining-1-Teil"><a href="#Pipelining-1-Teil" class="headerlink" title="Pipelining - 1 Teil"></a>Pipelining - 1 Teil</h2><h2 id="Zusatzvideos"><a href="#Zusatzvideos" class="headerlink" title="Zusatzvideos"></a>Zusatzvideos</h2><p><strong>was ist ein nop-Befehl</strong></p>
<ul>
<li>No Operation</li>
<li>Befehl der nichts ausfÃ¼hrt(keinen Zustand verÃ¤ndert)</li>
<li>gewÃ¶hnlich Befehl dessen 32 Bit auf 0 gesetzt sind</li>
<li>in MIPS: sll <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.853ex" height="1.439ex" role="img" focusable="false" viewbox="0 -442 2145 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mi" transform="translate(465,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(931,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1382,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mo" transform="translate(1867,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>zero, 0<br><strong>AuflÃ¶sung von Datenkonflikten in Pipelined-Prozessoren:</strong></li>
<li>nop-Befehle<ul>
<li>simpleres Design(weniger Baauteile/kostengÃ¼nstig)</li>
<li>Compiler/Programmierer muss manuell nopâ€™s einfÃ¼gen</li>
</ul>
</li>
<li>alternativ: Hardware-Forwarding</li>
</ul>
<h2 id="Was-macht-der-Pipeline-Prozessor-anders-als-der-Eintakt-Prozessor"><a href="#Was-macht-der-Pipeline-Prozessor-anders-als-der-Eintakt-Prozessor" class="headerlink" title="Was macht der Pipeline-Prozessor anders als der Eintakt-Prozessor"></a>Was macht der Pipeline-Prozessor anders als der Eintakt-Prozessor</h2><ul>
<li>ursprÃ¼ngliches Proplem bei Eintaktprozessor: Abschnitten im Eintaktprozessor werden nicht vollstÃ¤ndig ausgenutzt.</li>
<li><p>Idee: wir fangen an, Befehle auszufÃ¼hren, bevor der vorherige Befehl fertig ist.</p>
<ul>
<li>damit die Datenpfad-Abschnitte mehr genutzt werden (mehr Arbeit ausfÃ¼hren)</li>
<li>sobald der Befehl zu den Registern geht, wird schon ein neuer Befehl aus dem Speicher geladen</li>
</ul>
</li>
<li><p>wir haben 5 Abschnitte: Instruction Fetch, Instruction Decode, Execute, Memory (Read/Write), Write Back</p>
<ul>
<li>sobald ein Befehl in Instruction Decode ist, wird der nÃ¤chste Befehl angefangen</li>
</ul>
</li>
</ul>
<h2 id="Unterschied-zwischen-dem-Pipeline-Prozessor-und-Eintakt-Prozessor"><a href="#Unterschied-zwischen-dem-Pipeline-Prozessor-und-Eintakt-Prozessor" class="headerlink" title="Unterschied zwischen dem Pipeline-Prozessor und Eintakt-Prozessor"></a>Unterschied zwischen dem Pipeline-Prozessor und Eintakt-Prozessor</h2><ol>
<li>manche Bestandteile aus dem Eintaktprozessor wurden â€œbewegtâ€ an andere Stelle</li>
<li>es gibt solche â€œBalkenâ€ (zusÃ¤tzlichen Rechtecke) = Pipeline-Register</li>
</ol>
<h2 id="Wozu-sind-diese-neuen-â€œBalkenâ€-Pipeline-Register-uberhaupt-da"><a href="#Wozu-sind-diese-neuen-â€œBalkenâ€-Pipeline-Register-uberhaupt-da" class="headerlink" title="Wozu sind diese neuen â€œBalkenâ€ (Pipeline-Register) Ã¼berhaupt da?"></a>Wozu sind diese neuen â€œBalkenâ€ (Pipeline-Register) Ã¼berhaupt da?</h2><ul>
<li>diese trennen die verschiedenen Stufen</li>
<li><p>aber warum brauchen wir diese Register wirklich?</p>
<ul>
<li>weil wir jede Stufe in der gleichen Zeit ausfÃ¼hren wollen</li>
<li>wir wissen aus letzter Woche: die Stufen sind unterschiedlich schnell<br>(z.B. Instruction Fetch = Speicherzugriff 150ps, Register-Lesen = 50 ps, ALU = 100ps)</li>
<li>wir wollen nicht, dass eine frÃ¼here Stufe die nÃ¤chste vorzeitig unterbricht</li>
</ul>
<p>=&gt; die Pipeline-Register halten die Eingangsdaten (fÃ¼r eine Stufe) und warten, bis der nÃ¤chste Takt anfÃ¤ngt (Synchronisation)</p>
</li>
</ul>
<h2 id="Aufgabe-1-Toll-Aber-gibt-es-da-nicht-ein-Problem"><a href="#Aufgabe-1-Toll-Aber-gibt-es-da-nicht-ein-Problem" class="headerlink" title="Aufgabe 1: Toll! Aber, gibt es da nicht ein Problem??"></a>Aufgabe 1: Toll! Aber, gibt es da nicht ein Problem??</h2><ul>
<li><p>Datenkonflikte (Data Hazard)</p>
<ul>
<li>Register-Werte fehlen, wenn diese gebraucht werden</li>
<li>wenn ein Befehl das Ergebnis von dem vorherigen Befehl braucht, dann ist der vorherige Befehl noch nicht fertig!!<br>Die Daten des vorherigen Befehls sind nicht da<br>Die gelesen Register vom nÃ¤chsten Befehl (weiter links in der Pipeline) sind noch nicht upgedatet, also falsch</li>
<li><p>wir kÃ¶nnen das richtige Ergebnis erst aus dem Register laden, <strong>wÃ¤hrend</strong> das Ergebnis geschrieben wird<br>warum?</p>
<ul>
<li>Idee: wir kÃ¶nnen den Takt in zwei HÃ¤lften unterteilen</li>
<li>erste HÃ¤lfte: schreibe das Ergebnis in Register in Write Back</li>
<li>zweite HÃ¤lfte: Register werden gelesen in Instruction Decode</li>
</ul>
</li>
<li><p>wie kann machen, damit Data Hazards weniger Zeit verschwenden?</p>
<ul>
<li>Forwarding Unit + Hazard Detection (Ergebnis wird weitergereicht, sobald das Ergebnis berechnet wurde, also schon vor Write-Back)</li>
</ul>
</li>
</ul>
</li>
<li><p>Steuerkonflikte (Control Hazard)</p>
<ul>
<li>die Sprungentscheidung, Sprungadresse fehlt, wenn wir diese bereits brauchen</li>
<li>der Kontrollfluss (also die BefehlsausfÃ¼hrung) ist verzÃ¶gert (ist noch nicht entschieden)</li>
<li>wir kÃ¶nnen Befehle ausfÃ¼hren, die eigentlich nicht ausgefÃ¼hrt werden sollen</li>
<li><p>wie schneller machen?</p>
<ul>
<li>â€œBranch Predictionâ€ (siehe unten)<ul>
<li>wenn wir hÃ¤ufig richtig raten, sind wir schneller</li>
</ul>
</li>
<li>Sprungentscheidung viel frÃ¼her berechnen (z.B. in Instruction-Decode, dafÃ¼r Extra-Hardware nÃ¶tig)</li>
</ul>
</li>
</ul>
</li>
<li><p>Strukturelle Konflikte (Structural Hazard) (nennen wir nur wegen der VollstÃ¤ndigkeit)</p>
<ul>
<li>wenn zwei Befehle dieselbe Pipeline-Stufe gleichzeitig nutzen wollen</li>
<li>z.B. wenn es zwei Pipelines gibt (2K-Zahlen und Floating-Point-Zahlen) und diese zusammenlaufen (zusammengefÃ¼hrt werden)<ul>
<li>Advanced Computer Architectures</li>
</ul>
</li>
<li>kommen bei uns nicht vor</li>
</ul>
</li>
<li><p>wie verhindern (entschÃ¤rfen) wir die Hazards?</p>
<ul>
<li>â€œStall Cyclesâ€ (Takte wo angehalten wird), â€œder Prozessor hÃ¤lt die vordere Pipeline an (Instruction Fetch und Instruction Decode)</li>
<li>wir ignorieren das Problem, Compiler soll das Problem lÃ¶sen<ul>
<li>Compiler fÃ¼gt â€œWartebefehleâ€ ein, â€œNOPâ€s = No operation</li>
<li>Delay Slot (= Takte die gewartet werden mÃ¼ssen, bis das richtige Ergebnis da ist) = Latenz (â€œBearbeitungszeitâ€)<ul>
<li>wir kÃ¶nnen auch andere Befehle statt NOPs nutzen, die fehlende Ergebnis nicht brauchen</li>
</ul>
</li>
</ul>
</li>
<li>â€œFlushingâ€ (â€œherunterspÃ¼lenâ€)<ul>
<li>die Pipeline bis zu Instruction Decode wird geleert (d.h. das wir die Befehle spÃ¤ter nochmal laden)</li>
</ul>
</li>
<li>fÃ¼r Control Hazards: wir kÃ¶nnen raten (Spekulation, â€œBranch Predictionâ€), welche Sprungentscheidung genommen wird<ul>
<li>wenn wir falsch raten, dann werden wir bestraft, indem wir alle falsch ausgefÃ¼hrten Befehle rÃ¼ckgÃ¤ngig machen mÃ¼ssen (â€œFlushingâ€ + andere Sachen)</li>
<li>wenn wir richtig raten, dann sind wir richtig schnell ğŸ˜€</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Aufgabe-2"><a href="#Aufgabe-2" class="headerlink" title="Aufgabe 2:"></a>Aufgabe 2:</h2><p>a)</p>
<ul>
<li>ohne Optimierung:<ul>
<li>wenn ein Register-Ergebnis berechnet wird, dann ist das Ergebnis die nÃ¤chsten zwei Takte nicht verfÃ¼gbar</li>
<li>siehe Bild</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0    addi  *$t0* ,$a0 ,4</span><br><span class="line">1    addi  *$t1* ,$a1 ,4</span><br><span class="line">2    sub  $t2 ,*$t0* ,*$t1*</span><br><span class="line">3    sll  *$t3* ,$a2 ,2</span><br><span class="line">4    add  *$t4* ,$t0 ,*$t3*</span><br><span class="line">5    add  $t5 ,$t1 ,*$t3*</span><br><span class="line">6    sw  $t2 ,0( *$t4* )</span><br></pre></td></tr></table></figure>
<p>b)</p>
<ul>
<li>keine Reihenfolge Ã¤ndern, nur Wartebefehle (NOPs) einfÃ¼gen</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0    addi  $t0 ,$a0 ,4</span><br><span class="line"></span><br><span class="line">1    addi  $t1 ,$a1 ,4</span><br><span class="line"></span><br><span class="line">1.2  nop</span><br><span class="line">1.3  nop</span><br><span class="line"></span><br><span class="line">2    sub  $t2 , $t0 , $t1</span><br><span class="line"></span><br><span class="line">3    sll  $t3 ,$a2 ,2</span><br><span class="line"></span><br><span class="line">3.1  nop</span><br><span class="line">3.2  nop</span><br><span class="line"></span><br><span class="line">4    add  $t4 ,$t0 , $t3</span><br><span class="line"></span><br><span class="line">5    add  $t5 ,$t1 , $t3</span><br><span class="line"></span><br><span class="line">5.1  nop</span><br><span class="line"></span><br><span class="line">6    sw  $t2 ,0( $t4 )</span><br></pre></td></tr></table></figure>
<p>c)</p>
<ul>
<li>noch besser machen: jetzt so wenig wie mÃ¶glich NOPs brauchen, Befehle umordnen</li>
<li>wie vorgehen ? wir gucken, welche Befehle brauchen das Ergebnis von welchen anderen Befehlen? =&gt; grafisch aufzeichnen<ul>
<li>List Scheduling (siehe Internet? â†’ Compiler Design Kurs. Statt â€œAuftrÃ¤geâ€ â€œMaschinenâ€ zuzuweisen, weisen wir der Pipeline neue Befehle zu)</li>
</ul>
</li>
</ul>
<h2 id="Aufgabe-3-â€“-Geschwindigkeitsvergleich-zwischen-Pipelineprozessor-und-Eintaktprozessor"><a href="#Aufgabe-3-â€“-Geschwindigkeitsvergleich-zwischen-Pipelineprozessor-und-Eintaktprozessor" class="headerlink" title="Aufgabe 3 â€“ Geschwindigkeitsvergleich zwischen Pipelineprozessor und Eintaktprozessor"></a>Aufgabe 3 â€“ Geschwindigkeitsvergleich zwischen Pipelineprozessor und Eintaktprozessor</h2><p>a)</p>
<ul>
<li>Speicherzugriff = 200ps, ALU-Operation = 100ps, Registerzugriff = 50ps</li>
<li><p>Benchmark (Programm, um die AusfÃ¼hrungszeit zu messen)</p>
<ul>
<li>Annahmen: gleiche Anzahl an Befehle fÃ¼r beide Prozessoren</li>
<li>Jeder Prozessor hat eine (eigene) konstante Taktzeit, T_SC = Taktdauer des Eintaktprozessor (Single Cycle), T_PP = Taktdauer fÃ¼r Pipeline-Prozessor</li>
<li>es gibt keine Data Hazards mehr (wurden entfernt durch Umordnung)</li>
<li><p>es gibt aber alle Control-Hazards noch!  -&gt; jeder Sprungbefehl dauert 4 Takte! Der Prozessor hÃ¤lt bei Sprungbefehlen einfach an!</p>
</li>
<li><p>Speicherbefehle -&gt; 12%  (1 Takt pro Speicherbefehl weil keine Datenkonflikte Data Hazards)</p>
</li>
<li>ALU-Befehle -&gt; 72%   (1 Takt pro Speicherbefehl weil keine Datenkonflikte)</li>
<li>Sprung-Befehle -&gt; 16%   (4 Takte pro Sprungbefehl, wegen den Steuerkonflikten Control Hazards)</li>
<li><p>wozu die Informationen? Damit wir die Schnelligkeit des Pipeline-Prozessors berechnen kÃ¶nnen. Eintaktprozessor fÃ¼hrt jeden Befehl gleichschnell aus</p>
</li>
<li><p>unbekannte Anzahl N an Befehlen</p>
</li>
<li>Pipeline ist zu Beginn der Benchmark gefÃ¼llt</li>
</ul>
</li>
<li><p>Speedup berechnen, S = Vergleichszeit t_SC / (betrachtete Zeit) t_PP  -&gt; wie viel Faktor schneller ist der betrachtete Prozessor</p>
</li>
<li>t_SC = AusfÃ¼hrungszeit Eintaktprozessor   = (Anzahl an Takte) Â· (Taktdauer) = (N Â· CPI_SC) Â· T_SC</li>
<li>t_PP = AusfÃ¼hrungszeit Pipelineprozessor  = (Anzahl an Takte) Â· (Taktdauer) = (N Â· CPI_PP) Â· T_PP</li>
<li>CPI = Befehlsdauer in Takten = wie lange braucht ein Befehl an Takten zur AusfÃ¼hrung<ul>
<li>CPI_SC = 1 da jeder Befehl einen Takt braucht</li>
<li>CPI_PP = jeder Befehl braucht unterschiedlich viele Takte (hÃ¤ngt ab von den Hazards)<ul>
<li>gewichteter Mittelwert: 12% <em> 1 + 72% </em> 1 + 16% * 4  = 1.48</li>
</ul>
</li>
</ul>
</li>
<li><p>T = Taktdauer, wie viel Sekunden braucht ein Takt</p>
<ul>
<li>T_SC = 600ps = 2Â·200ps + 100ps + 2Â·50ps  (2-mal Speicherzugriff, 2-mal Registerzugriff, 1-mal ALU)</li>
<li>T_PP = maximale Dauer einer Stufe = 200ps (wir brauchen eine Taktdauer in der jede Stufe ausgefÃ¼hrt wird)</li>
</ul>
</li>
<li><p>S = (N Â· CPI_SC) Â· T_SC / ((N Â· CPI_PP) Â· T_PP)  = 600ps / (1.48 * 200ps) = 2,027027027â€¦ = 2 + 27/999</p>
</li>
</ul>
<p>b) wie kÃ¶nnen wir den Pipeline-Prozessor schneller machen? siehe Aufgabe 1</p>
<p>c) Was ist, wenn wir nur die ALU schneller machen, um 25% ?</p>
<p>ALU-Operation braucht nur 75ps</p>
<p>-&gt; T_SC = 2Â·200ps + 75ps + 2Â·50ps = 575ps</p>
<p>T_PP Ã¤ndert sich nicht!! Immernoch die gleichen Hazards, und Speicherbefehle dauern immernoch 200ps</p>
<p>=&gt; der Speedup wird schlechter, weil der Pipeline-Prozessor nicht profitiert</p>
<p>=&gt; Pipeline wird nur schneller, wenn man die am lÃ¤ngsten dauernde Stufe optimiert.</p>
<h2 id="Pipelining-2-Teil"><a href="#Pipelining-2-Teil" class="headerlink" title="Pipelining - 2 Teil"></a>Pipelining - 2 Teil</h2><p><img src="/images/20230203105924.png" alt><br><img src="/images/BildschirmÂ­foto%202023-02-03%20um%2010.51.40.png" alt><br><img src="/images/BildschirmÂ­foto%202023-02-03%20um%2011.48.40.png" alt></p>
<p><strong>Aufgabe 3</strong></p>
<p>a) Verbesserung ist, dass man die EX und MEM-Stufe zusammenlegen kann. Die Pipeline wird kÃ¼rzer. Load-Use-Konflikte sind einen Takt schneller (0 statt 1 Takte VerzÃ¶gerung).</p>
<p>b)</p>
<p>Verbesserungen gibt es, wenn Speicherfefehle keinen Offset brauchen</p>
<p>das ist der Fall bei Array-Zugriffen in Schleifen oder Integer-Pointer</p>
<p>alle anderen Zugriffe brauchen einen Offset</p>
<p>wenn man einen konstanten Offset braucht, wird man verlangsamt</p>
<p>der Offset muss in Extra-Befehl berechnet werden</p>
<p>der zusÃ¤tzliche Befehl wird nur durch kÃ¼rzere Load-Use-Hazards kompensiert</p>
<p>verbraucht ein Register (erhÃ¶ht den Registerdruck), sowie zusÃ¤tzlichen Platz im Befehlsspeicher (Cache-Verschmutzung)</p>
<p>in Praxis brauchen wahrscheinlich mehr Befehle einen konstanten Offset als keinen</p>
<p>alle struct-, Objekt-Zugriffe brauchen einen; hÃ¤ufiger Spezialfall: Stack-Frames</p>
<p>hÃ¤ufig in Praxis, vor allem Stack Frames, da es viel mehr innere Funktionsaufrufe mit Stack als Blatt-Funktionsaufrufe ohne Stack gibt.</p>
<p><img src="/images/20230203131555.png" alt><br><img src="/images/20230203131618.png" alt><br><img src="/images/20230203131640.png" alt>  </p>


                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                                

<a href="/categories/Rechnerorganisation/">Rechnerorganisation</a>

                                                    
                                </div>
                                <div class="post-date">
                                    
                                        2023-02-03
                                    
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    

<!-- TOC -->

    <aside id="article-toc" role="navigation" class="fixed">
        <div id="article-toc-inner">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Rechnerorganisasion-TUT-11"><span class="toc-text">Rechnerorganisasion TUT 11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipelining-1-Teil"><span class="toc-text">Pipelining - 1 Teil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zusatzvideos"><span class="toc-text">Zusatzvideos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Was-macht-der-Pipeline-Prozessor-anders-als-der-Eintakt-Prozessor"><span class="toc-text">Was macht der Pipeline-Prozessor anders als der Eintakt-Prozessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unterschied-zwischen-dem-Pipeline-Prozessor-und-Eintakt-Prozessor"><span class="toc-text">Unterschied zwischen dem Pipeline-Prozessor und Eintakt-Prozessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wozu-sind-diese-neuen-%E2%80%9CBalken%E2%80%9D-Pipeline-Register-uberhaupt-da"><span class="toc-text">Wozu sind diese neuen â€œBalkenâ€ (Pipeline-Register) Ã¼berhaupt da?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aufgabe-1-Toll-Aber-gibt-es-da-nicht-ein-Problem"><span class="toc-text">Aufgabe 1: Toll! Aber, gibt es da nicht ein Problem??</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aufgabe-2"><span class="toc-text">Aufgabe 2:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aufgabe-3-%E2%80%93-Geschwindigkeitsvergleich-zwischen-Pipelineprozessor-und-Eintaktprozessor"><span class="toc-text">Aufgabe 3 â€“ Geschwindigkeitsvergleich zwischen Pipelineprozessor und Eintaktprozessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipelining-2-Teil"><span class="toc-text">Pipelining - 2 Teil</span></a></li></ol></li></ol>
        </div>
    </aside>

    <!-- Scripts -->
    <script type="text/javascript">
    console.log("Â© zchen9 ğŸ™‹ 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    

    <!-- Service Worker -->
    <!-- if using service worker -->

    
</body>

</html>