<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Pipelining">
    

    <!--Author-->
    
        <meta name="author" content="Yilong Wang">
    

    <!-- Title -->
    
    <title>Rorg_11 | 25HUASHENG</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.jsdelivr.net/npm/bootstrap@3.3.6/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.jsdelivr.net/npm/font-awesome@4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.jsdelivr.net/npm/bootstrap@3.3.6/dist/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                Rorg_11
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <p>Pipelining<br><span id="more"></span></p>
<h1 id="Rechnerorganisasion-TUT-11"><a href="#Rechnerorganisasion-TUT-11" class="headerlink" title="Rechnerorganisasion TUT 11"></a>Rechnerorganisasion TUT 11</h1><h2 id="Pipelining-1-Teil"><a href="#Pipelining-1-Teil" class="headerlink" title="Pipelining - 1 Teil"></a>Pipelining - 1 Teil</h2><h2 id="Zusatzvideos"><a href="#Zusatzvideos" class="headerlink" title="Zusatzvideos"></a>Zusatzvideos</h2><p><strong>was ist ein nop-Befehl</strong></p>
<ul>
<li>No Operation</li>
<li>Befehl der nichts ausführt(keinen Zustand verändert)</li>
<li>gewöhnlich Befehl dessen 32 Bit auf 0 gesetzt sind</li>
<li>in MIPS: sll <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.853ex" height="1.439ex" role="img" focusable="false" viewbox="0 -442 2145 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mi" transform="translate(465,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(931,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1382,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mo" transform="translate(1867,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g></g></g></svg></mjx-container>zero, 0<br><strong>Auflösung von Datenkonflikten in Pipelined-Prozessoren:</strong></li>
<li>nop-Befehle<ul>
<li>simpleres Design(weniger Baauteile/kostengünstig)</li>
<li>Compiler/Programmierer muss manuell nop’s einfügen</li>
</ul>
</li>
<li>alternativ: Hardware-Forwarding</li>
</ul>
<h2 id="Was-macht-der-Pipeline-Prozessor-anders-als-der-Eintakt-Prozessor"><a href="#Was-macht-der-Pipeline-Prozessor-anders-als-der-Eintakt-Prozessor" class="headerlink" title="Was macht der Pipeline-Prozessor anders als der Eintakt-Prozessor"></a>Was macht der Pipeline-Prozessor anders als der Eintakt-Prozessor</h2><ul>
<li>ursprüngliches Proplem bei Eintaktprozessor: Abschnitten im Eintaktprozessor werden nicht vollständig ausgenutzt.</li>
<li><p>Idee: wir fangen an, Befehle auszuführen, bevor der vorherige Befehl fertig ist.</p>
<ul>
<li>damit die Datenpfad-Abschnitte mehr genutzt werden (mehr Arbeit ausführen)</li>
<li>sobald der Befehl zu den Registern geht, wird schon ein neuer Befehl aus dem Speicher geladen</li>
</ul>
</li>
<li><p>wir haben 5 Abschnitte: Instruction Fetch, Instruction Decode, Execute, Memory (Read/Write), Write Back</p>
<ul>
<li>sobald ein Befehl in Instruction Decode ist, wird der nächste Befehl angefangen</li>
</ul>
</li>
</ul>
<h2 id="Unterschied-zwischen-dem-Pipeline-Prozessor-und-Eintakt-Prozessor"><a href="#Unterschied-zwischen-dem-Pipeline-Prozessor-und-Eintakt-Prozessor" class="headerlink" title="Unterschied zwischen dem Pipeline-Prozessor und Eintakt-Prozessor"></a>Unterschied zwischen dem Pipeline-Prozessor und Eintakt-Prozessor</h2><ol>
<li>manche Bestandteile aus dem Eintaktprozessor wurden “bewegt” an andere Stelle</li>
<li>es gibt solche “Balken” (zusätzlichen Rechtecke) = Pipeline-Register</li>
</ol>
<h2 id="Wozu-sind-diese-neuen-“Balken”-Pipeline-Register-uberhaupt-da"><a href="#Wozu-sind-diese-neuen-“Balken”-Pipeline-Register-uberhaupt-da" class="headerlink" title="Wozu sind diese neuen “Balken” (Pipeline-Register) überhaupt da?"></a>Wozu sind diese neuen “Balken” (Pipeline-Register) überhaupt da?</h2><ul>
<li>diese trennen die verschiedenen Stufen</li>
<li><p>aber warum brauchen wir diese Register wirklich?</p>
<ul>
<li>weil wir jede Stufe in der gleichen Zeit ausführen wollen</li>
<li>wir wissen aus letzter Woche: die Stufen sind unterschiedlich schnell<br>(z.B. Instruction Fetch = Speicherzugriff 150ps, Register-Lesen = 50 ps, ALU = 100ps)</li>
<li>wir wollen nicht, dass eine frühere Stufe die nächste vorzeitig unterbricht</li>
</ul>
<p>=&gt; die Pipeline-Register halten die Eingangsdaten (für eine Stufe) und warten, bis der nächste Takt anfängt (Synchronisation)</p>
</li>
</ul>
<h2 id="Aufgabe-1-Toll-Aber-gibt-es-da-nicht-ein-Problem"><a href="#Aufgabe-1-Toll-Aber-gibt-es-da-nicht-ein-Problem" class="headerlink" title="Aufgabe 1: Toll! Aber, gibt es da nicht ein Problem??"></a>Aufgabe 1: Toll! Aber, gibt es da nicht ein Problem??</h2><ul>
<li><p>Datenkonflikte (Data Hazard)</p>
<ul>
<li>Register-Werte fehlen, wenn diese gebraucht werden</li>
<li>wenn ein Befehl das Ergebnis von dem vorherigen Befehl braucht, dann ist der vorherige Befehl noch nicht fertig!!<br>Die Daten des vorherigen Befehls sind nicht da<br>Die gelesen Register vom nächsten Befehl (weiter links in der Pipeline) sind noch nicht upgedatet, also falsch</li>
<li><p>wir können das richtige Ergebnis erst aus dem Register laden, <strong>während</strong> das Ergebnis geschrieben wird<br>warum?</p>
<ul>
<li>Idee: wir können den Takt in zwei Hälften unterteilen</li>
<li>erste Hälfte: schreibe das Ergebnis in Register in Write Back</li>
<li>zweite Hälfte: Register werden gelesen in Instruction Decode</li>
</ul>
</li>
<li><p>wie kann machen, damit Data Hazards weniger Zeit verschwenden?</p>
<ul>
<li>Forwarding Unit + Hazard Detection (Ergebnis wird weitergereicht, sobald das Ergebnis berechnet wurde, also schon vor Write-Back)</li>
</ul>
</li>
</ul>
</li>
<li><p>Steuerkonflikte (Control Hazard)</p>
<ul>
<li>die Sprungentscheidung, Sprungadresse fehlt, wenn wir diese bereits brauchen</li>
<li>der Kontrollfluss (also die Befehlsausführung) ist verzögert (ist noch nicht entschieden)</li>
<li>wir können Befehle ausführen, die eigentlich nicht ausgeführt werden sollen</li>
<li><p>wie schneller machen?</p>
<ul>
<li>“Branch Prediction” (siehe unten)<ul>
<li>wenn wir häufig richtig raten, sind wir schneller</li>
</ul>
</li>
<li>Sprungentscheidung viel früher berechnen (z.B. in Instruction-Decode, dafür Extra-Hardware nötig)</li>
</ul>
</li>
</ul>
</li>
<li><p>Strukturelle Konflikte (Structural Hazard) (nennen wir nur wegen der Vollständigkeit)</p>
<ul>
<li>wenn zwei Befehle dieselbe Pipeline-Stufe gleichzeitig nutzen wollen</li>
<li>z.B. wenn es zwei Pipelines gibt (2K-Zahlen und Floating-Point-Zahlen) und diese zusammenlaufen (zusammengeführt werden)<ul>
<li>Advanced Computer Architectures</li>
</ul>
</li>
<li>kommen bei uns nicht vor</li>
</ul>
</li>
<li><p>wie verhindern (entschärfen) wir die Hazards?</p>
<ul>
<li>“Stall Cycles” (Takte wo angehalten wird), “der Prozessor hält die vordere Pipeline an (Instruction Fetch und Instruction Decode)</li>
<li>wir ignorieren das Problem, Compiler soll das Problem lösen<ul>
<li>Compiler fügt “Wartebefehle” ein, “NOP”s = No operation</li>
<li>Delay Slot (= Takte die gewartet werden müssen, bis das richtige Ergebnis da ist) = Latenz (“Bearbeitungszeit”)<ul>
<li>wir können auch andere Befehle statt NOPs nutzen, die fehlende Ergebnis nicht brauchen</li>
</ul>
</li>
</ul>
</li>
<li>“Flushing” (“herunterspülen”)<ul>
<li>die Pipeline bis zu Instruction Decode wird geleert (d.h. das wir die Befehle später nochmal laden)</li>
</ul>
</li>
<li>für Control Hazards: wir können raten (Spekulation, “Branch Prediction”), welche Sprungentscheidung genommen wird<ul>
<li>wenn wir falsch raten, dann werden wir bestraft, indem wir alle falsch ausgeführten Befehle rückgängig machen müssen (“Flushing” + andere Sachen)</li>
<li>wenn wir richtig raten, dann sind wir richtig schnell 😀</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Aufgabe-2"><a href="#Aufgabe-2" class="headerlink" title="Aufgabe 2:"></a>Aufgabe 2:</h2><p>a)</p>
<ul>
<li>ohne Optimierung:<ul>
<li>wenn ein Register-Ergebnis berechnet wird, dann ist das Ergebnis die nächsten zwei Takte nicht verfügbar</li>
<li>siehe Bild</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0    addi  *$t0* ,$a0 ,4</span><br><span class="line">1    addi  *$t1* ,$a1 ,4</span><br><span class="line">2    sub  $t2 ,*$t0* ,*$t1*</span><br><span class="line">3    sll  *$t3* ,$a2 ,2</span><br><span class="line">4    add  *$t4* ,$t0 ,*$t3*</span><br><span class="line">5    add  $t5 ,$t1 ,*$t3*</span><br><span class="line">6    sw  $t2 ,0( *$t4* )</span><br></pre></td></tr></table></figure>
<p>b)</p>
<ul>
<li>keine Reihenfolge ändern, nur Wartebefehle (NOPs) einfügen</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0    addi  $t0 ,$a0 ,4</span><br><span class="line"></span><br><span class="line">1    addi  $t1 ,$a1 ,4</span><br><span class="line"></span><br><span class="line">1.2  nop</span><br><span class="line">1.3  nop</span><br><span class="line"></span><br><span class="line">2    sub  $t2 , $t0 , $t1</span><br><span class="line"></span><br><span class="line">3    sll  $t3 ,$a2 ,2</span><br><span class="line"></span><br><span class="line">3.1  nop</span><br><span class="line">3.2  nop</span><br><span class="line"></span><br><span class="line">4    add  $t4 ,$t0 , $t3</span><br><span class="line"></span><br><span class="line">5    add  $t5 ,$t1 , $t3</span><br><span class="line"></span><br><span class="line">5.1  nop</span><br><span class="line"></span><br><span class="line">6    sw  $t2 ,0( $t4 )</span><br></pre></td></tr></table></figure>
<p>c)</p>
<ul>
<li>noch besser machen: jetzt so wenig wie möglich NOPs brauchen, Befehle umordnen</li>
<li>wie vorgehen ? wir gucken, welche Befehle brauchen das Ergebnis von welchen anderen Befehlen? =&gt; grafisch aufzeichnen<ul>
<li>List Scheduling (siehe Internet? → Compiler Design Kurs. Statt “Aufträge” “Maschinen” zuzuweisen, weisen wir der Pipeline neue Befehle zu)</li>
</ul>
</li>
</ul>
<h2 id="Aufgabe-3-–-Geschwindigkeitsvergleich-zwischen-Pipelineprozessor-und-Eintaktprozessor"><a href="#Aufgabe-3-–-Geschwindigkeitsvergleich-zwischen-Pipelineprozessor-und-Eintaktprozessor" class="headerlink" title="Aufgabe 3 – Geschwindigkeitsvergleich zwischen Pipelineprozessor und Eintaktprozessor"></a>Aufgabe 3 – Geschwindigkeitsvergleich zwischen Pipelineprozessor und Eintaktprozessor</h2><p>a)</p>
<ul>
<li>Speicherzugriff = 200ps, ALU-Operation = 100ps, Registerzugriff = 50ps</li>
<li><p>Benchmark (Programm, um die Ausführungszeit zu messen)</p>
<ul>
<li>Annahmen: gleiche Anzahl an Befehle für beide Prozessoren</li>
<li>Jeder Prozessor hat eine (eigene) konstante Taktzeit, T_SC = Taktdauer des Eintaktprozessor (Single Cycle), T_PP = Taktdauer für Pipeline-Prozessor</li>
<li>es gibt keine Data Hazards mehr (wurden entfernt durch Umordnung)</li>
<li><p>es gibt aber alle Control-Hazards noch!  -&gt; jeder Sprungbefehl dauert 4 Takte! Der Prozessor hält bei Sprungbefehlen einfach an!</p>
</li>
<li><p>Speicherbefehle -&gt; 12%  (1 Takt pro Speicherbefehl weil keine Datenkonflikte Data Hazards)</p>
</li>
<li>ALU-Befehle -&gt; 72%   (1 Takt pro Speicherbefehl weil keine Datenkonflikte)</li>
<li>Sprung-Befehle -&gt; 16%   (4 Takte pro Sprungbefehl, wegen den Steuerkonflikten Control Hazards)</li>
<li><p>wozu die Informationen? Damit wir die Schnelligkeit des Pipeline-Prozessors berechnen können. Eintaktprozessor führt jeden Befehl gleichschnell aus</p>
</li>
<li><p>unbekannte Anzahl N an Befehlen</p>
</li>
<li>Pipeline ist zu Beginn der Benchmark gefüllt</li>
</ul>
</li>
<li><p>Speedup berechnen, S = Vergleichszeit t_SC / (betrachtete Zeit) t_PP  -&gt; wie viel Faktor schneller ist der betrachtete Prozessor</p>
</li>
<li>t_SC = Ausführungszeit Eintaktprozessor   = (Anzahl an Takte) · (Taktdauer) = (N · CPI_SC) · T_SC</li>
<li>t_PP = Ausführungszeit Pipelineprozessor  = (Anzahl an Takte) · (Taktdauer) = (N · CPI_PP) · T_PP</li>
<li>CPI = Befehlsdauer in Takten = wie lange braucht ein Befehl an Takten zur Ausführung<ul>
<li>CPI_SC = 1 da jeder Befehl einen Takt braucht</li>
<li>CPI_PP = jeder Befehl braucht unterschiedlich viele Takte (hängt ab von den Hazards)<ul>
<li>gewichteter Mittelwert: 12% <em> 1 + 72% </em> 1 + 16% * 4  = 1.48</li>
</ul>
</li>
</ul>
</li>
<li><p>T = Taktdauer, wie viel Sekunden braucht ein Takt</p>
<ul>
<li>T_SC = 600ps = 2·200ps + 100ps + 2·50ps  (2-mal Speicherzugriff, 2-mal Registerzugriff, 1-mal ALU)</li>
<li>T_PP = maximale Dauer einer Stufe = 200ps (wir brauchen eine Taktdauer in der jede Stufe ausgeführt wird)</li>
</ul>
</li>
<li><p>S = (N · CPI_SC) · T_SC / ((N · CPI_PP) · T_PP)  = 600ps / (1.48 * 200ps) = 2,027027027… = 2 + 27/999</p>
</li>
</ul>
<p>b) wie können wir den Pipeline-Prozessor schneller machen? siehe Aufgabe 1</p>
<p>c) Was ist, wenn wir nur die ALU schneller machen, um 25% ?</p>
<p>ALU-Operation braucht nur 75ps</p>
<p>-&gt; T_SC = 2·200ps + 75ps + 2·50ps = 575ps</p>
<p>T_PP ändert sich nicht!! Immernoch die gleichen Hazards, und Speicherbefehle dauern immernoch 200ps</p>
<p>=&gt; der Speedup wird schlechter, weil der Pipeline-Prozessor nicht profitiert</p>
<p>=&gt; Pipeline wird nur schneller, wenn man die am längsten dauernde Stufe optimiert.</p>
<h2 id="Pipelining-2-Teil"><a href="#Pipelining-2-Teil" class="headerlink" title="Pipelining - 2 Teil"></a>Pipelining - 2 Teil</h2><p><img src="/images/20230203105924.png" alt><br><img src="/images/Bildschirm­foto%202023-02-03%20um%2010.51.40.png" alt><br><img src="/images/Bildschirm­foto%202023-02-03%20um%2011.48.40.png" alt></p>
<p><strong>Aufgabe 3</strong></p>
<p>a) Verbesserung ist, dass man die EX und MEM-Stufe zusammenlegen kann. Die Pipeline wird kürzer. Load-Use-Konflikte sind einen Takt schneller (0 statt 1 Takte Verzögerung).</p>
<p>b)</p>
<p>Verbesserungen gibt es, wenn Speicherfefehle keinen Offset brauchen</p>
<p>das ist der Fall bei Array-Zugriffen in Schleifen oder Integer-Pointer</p>
<p>alle anderen Zugriffe brauchen einen Offset</p>
<p>wenn man einen konstanten Offset braucht, wird man verlangsamt</p>
<p>der Offset muss in Extra-Befehl berechnet werden</p>
<p>der zusätzliche Befehl wird nur durch kürzere Load-Use-Hazards kompensiert</p>
<p>verbraucht ein Register (erhöht den Registerdruck), sowie zusätzlichen Platz im Befehlsspeicher (Cache-Verschmutzung)</p>
<p>in Praxis brauchen wahrscheinlich mehr Befehle einen konstanten Offset als keinen</p>
<p>alle struct-, Objekt-Zugriffe brauchen einen; häufiger Spezialfall: Stack-Frames</p>
<p>häufig in Praxis, vor allem Stack Frames, da es viel mehr innere Funktionsaufrufe mit Stack als Blatt-Funktionsaufrufe ohne Stack gibt.</p>
<p><img src="/images/20230203131555.png" alt><br><img src="/images/20230203131618.png" alt><br><img src="/images/20230203131640.png" alt>  </p>


                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                                

<a href="/categories/Rechnerorganisation/">Rechnerorganisation</a>

                                                    
                                </div>
                                <div class="post-date">
                                    
                                        2023-02-03
                                    
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    

<!-- TOC -->

    <aside id="article-toc" role="navigation" class="fixed">
        <div id="article-toc-inner">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Rechnerorganisasion-TUT-11"><span class="toc-text">Rechnerorganisasion TUT 11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipelining-1-Teil"><span class="toc-text">Pipelining - 1 Teil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zusatzvideos"><span class="toc-text">Zusatzvideos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Was-macht-der-Pipeline-Prozessor-anders-als-der-Eintakt-Prozessor"><span class="toc-text">Was macht der Pipeline-Prozessor anders als der Eintakt-Prozessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unterschied-zwischen-dem-Pipeline-Prozessor-und-Eintakt-Prozessor"><span class="toc-text">Unterschied zwischen dem Pipeline-Prozessor und Eintakt-Prozessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wozu-sind-diese-neuen-%E2%80%9CBalken%E2%80%9D-Pipeline-Register-uberhaupt-da"><span class="toc-text">Wozu sind diese neuen “Balken” (Pipeline-Register) überhaupt da?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aufgabe-1-Toll-Aber-gibt-es-da-nicht-ein-Problem"><span class="toc-text">Aufgabe 1: Toll! Aber, gibt es da nicht ein Problem??</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aufgabe-2"><span class="toc-text">Aufgabe 2:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aufgabe-3-%E2%80%93-Geschwindigkeitsvergleich-zwischen-Pipelineprozessor-und-Eintaktprozessor"><span class="toc-text">Aufgabe 3 – Geschwindigkeitsvergleich zwischen Pipelineprozessor und Eintaktprozessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipelining-2-Teil"><span class="toc-text">Pipelining - 2 Teil</span></a></li></ol></li></ol>
        </div>
    </aside>

    <!-- Scripts -->
    <script type="text/javascript">
    console.log("© zchen9 🙋 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    

    <!-- Service Worker -->
    <!-- if using service worker -->

    
</body>

</html>